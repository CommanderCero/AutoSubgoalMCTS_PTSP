import jpype
import jpype.imports
from jpype.types import *
import pathlib

from bayes_opt import BayesianOptimization
from bayes_opt.logger import JSONLogger
from bayes_opt.event import Events
from bayes_opt.util import load_logs
import math
import json
import os
import glob

def execSafe(func, *args):
    import java.lang.Exception
    try:
        return func(*args)
    except java.lang.Exception:
        return -10 # -1 is the lowest score reachable by normal means, so we return something even lower

def main():
    # Parse arguments
    import argparse
    parser = argparse.ArgumentParser(description='Runs a bayesian optimisation for some of the algorithms defined in the PTSP framework')
    parser.add_argument('--algorithm',
                        choices=["QD-MCTS", "S-MCTS", "MS-MCTS", "VanillaGA", "VanillaMCTS"],
                        help='The algorithm that should be optimized',
                        default="S-MCTS")
    parser.add_argument('--outputDir', 
                        default="./optimizationResults",
                        help='The output directory for all data generated by the optimization')
    parser.add_argument("--ptspPath",
                        default="./ptsp.jar",
                        help="The path to the .jar file containing the PTSP framework")
    parser.add_argument("--iters",
                        default="10",
                        type=int,
                        help="Number of parameter-points to test by the bayesian optimization")
    args = parser.parse_args()
    args.outputPath = f"{args.outputDir}/{args.algorithm}"
    
    # Find all previous logs for this optimization
    logs = glob.glob(f"{args.outputPath}/optimizationLogs*.json")
    csvLogs = glob.glob(f"{args.outputPath}/*.csv")
    
    # Launch the JVM
    jpype.startJVM()
    jpype.addClassPath(args.ptspPath)
    import framework.Optimization as optim
    
    # Move java output into a file
    from java.lang import System
    from java.io import PrintStream, FileOutputStream
    pathlib.Path(args.outputPath).mkdir(parents=True, exist_ok=True)
    System.setOut(PrintStream(FileOutputStream(f"{args.outputPath}/cout.txt", True)))
    
    # Algorithm specific data
    bounds = {
        "QD-MCTS" : {
                "lowER": (0.01, 10), # Exploration rate low-level search
                "highER": (0.01, 10), # Exploration rate high-level search
                "steps": (300, 600),  # Number of steps for low-level search
                "rd": (10, 30) # rolloutDepth
            },
        "S-MCTS" : {
                "cellSize": (5, 30), # Size of a cell in the subgoal grid (aka distance between subgoals)
                "er": (0.01, 10), # Exploration rate high-level search
                "steps": (300, 600),  # Number of steps for low-level search
                "rd": (10, 30) # rolloutDepth
            },
        "MS-MCTS" : {
                "cellSize": (5, 30), # Size of a cell in the subgoal grid (aka distance between subgoals)
                "er": (0.01, 10), # Exploration rate high-level search
                "steps": (300, 600),  # Number of steps for low-level search
                "rd": (10, 30) # rolloutDepth
            },
        "VanillaGA" : {
                "gl": (10, 30), # How many base-actions does a genome contain
                "ps": (1, 100), # How many genomes in one population
                "mr": (0.1, 0.9),  # Probability that an action is mutated
            },
        "VanillaMCTS" : {
                "er": (0.01, 10), # Exploration rate
                "rd": (10, 30), # RolloutDepth
            }
    }
    
    funcs = {
        "QD-MCTS" : lambda lowER, highER, steps, rd: execSafe(optim.runQD_MCTS, lowER, highER, round(steps), round(rd)),
        "S-MCTS" : lambda cellSize, er, steps, rd: execSafe(optim.runSMCTS, cellSize, er, round(steps), round(rd)),
        "MS-MCTS" : lambda cellSize, er, steps, rd: execSafe(optim.runMS_MCTS, cellSize, er, round(steps), round(rd)),
        "VanillaGA" : lambda gl, ps, mr: execSafe(optim.runVanillaGA, round(gl), round(ps), mr),
        "VanillaMCTS" : lambda er, rd: execSafe(optim.runVanillaMCTS, er, round(rd))
    }
    
    # Probe points for each algorithm, only one which I've used previously
    probes = {
        "QD-MCTS" : {"lowER": math.sqrt(2), "highER": 4, "steps": 400, "rd": 25},
        "S-MCTS" : {"cellSize": 20, "er": 4, "steps": 400, "rd": 25},
        "MS-MCTS" : {"cellSize": 20, "er": 4, "steps": 400, "rd": 25},
        "VanillaGA" : {"gl": 20, "ps": 50, "mr": 1. / 20},
        "VanillaMCTS" : {"er": math.sqrt(2), "rd": 12}
    }
    
    # Initialize optimization
    optim.setupRun(len(logs) * 11) # Different seed for each run
    optim.RUN_COUNTER = len(csvLogs) # Make sure java logs into a new csv file
    optim.NUM_TRIALS = 10
    optim.OutputDir = args.outputPath
    optim.m_mapNames = glob.glob("./maps/**/*.map", recursive=True)
    
    optimizer = BayesianOptimization(
        f=funcs[args.algorithm],
        pbounds=bounds[args.algorithm],
        random_state=len(logs) * 11, # Change behaviour for each run
    )
    print(f"Optimizing {args.algorithm} with bounds:")
    print(bounds[args.algorithm])
    
    # Probe if necessary
    init_points = 0
    if len(logs) == 0:
        print("Found no previous logs... Probing to improve results:")
        print(probes[args.algorithm])
        optimizer.probe(params=probes[args.algorithm], lazy=True)
        init_points = 5
    else: # If we found logs, load them
        print(f"Reading previous logs into optimizer...")
        load_logs(optimizer, logs=logs);
        for log in logs:
            print(f"Successfully loaded {log}")
    
    logger = JSONLogger(path=f"{args.outputPath}/optimizationLogs{len(logs) + 1}.json")
    optimizer.subscribe(Events.OPTIMIZATION_STEP, logger)
    
    # Run optimization
    print(f"Starting optimisation for {args.algorithm}...")
    optimizer.maximize(init_points=init_points, n_iter=args.iters)
    print("Finished optimisation")
    print(optimizer.max)
    

if __name__ == "__main__":
    main()
